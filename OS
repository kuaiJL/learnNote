    为什么需要多进程？因为在批处理系统中，都是等一个任务完成过后，再去执行另外一个任务。但是如果其中的一个任务需要执行大量的IO读写操作，而不是CPU密集型计算任务。 
但由于CPU和IO设备之间的读写速度差距太大，所以导致CPU的利用率不高，（就像烧水和写作业，烧水是任务1，写作业是任务2。
当你执行烧水的时候，首先需要烧水，这个烧水就对应耗时的IO操作，你烧水的时候会一直在那等着水烧开，而不去做其他事吗？
所以我们可以去写作业，相当于切换任务，等到水烧开了水壶就响了，我们就可以做水烧开之后的事。这样就能充分利用我们的大脑。
但是有的同学可能就会有疑问，既然水壶会响，相当于中断来通知我，我们任务1执行烧水的时候，能不能并不切换去做作业，
因为如果任务一还有其他的cpu密集型的计算，也可以充分利用cpu啊。针对这个疑问，要知道可能我们烧水就是为了煮泡面，只有水开了我们才能煮，
也就是大部分情况下后面的事要依赖前面事情的结果，所以我们没法边烧水边煮面。所以就想着在任务1执行的时候，执行到比较复杂的IO操作的时候就切换到另外一个任务2。
然后等之前那个io设备读写完成之后，再切换到之前的那个任务继续执行。这样的话就可以充分利用cpu，这种多个程序交替执行的思想就是多线程的图像。

    那为什么需要多线程呢，因为有这样的需求，就是比如看视频时边下载边播放的功能，因为如果你想等一个视频下好了再播放，可能用户已经等不及了不看了。
那怎么实现这样的功能呢，从现有的技术出发的话，那就是开多个进程就好了呀，一个做下载，一个做播放。通过操作系统利用cpu进行进程切换，实现并行。
这就涉及到进程间通信的问题。但是出于操作系统安全的考虑，往往2个进程间隔离性比较大，不能一个进程轻松的访问和修改另外一个进程的内存空间，否则会导致很混乱和不安全。
那既然不能读取和修改其他进程的内存空间，那么可以通过操作系统进行数据的传递，但是这种传递的过程中会进行大量的数据拷贝，代价很大。所以有没有一种机制可以很好的解决这样的需求呢。

    我们仔细观察这样的需求，既然需要边下载边播放，那么我们能不能制造出一个类似进程的东西，可以让他们共享内存空间，那么这就是线程的设计想法
，一个进程可以包含多个执行序列，而这些执行序列就是线程，因为在一个进程里，可以共享内存，切换的时候不用像那样需要切换内存映射表等很多资源。
只需要切换自身运行序列的栈和寄存器。所以说线程切换的开销比较进程切换要小很多。

    那么如何实现线程切换呢，既然线程切换就是执行序列的切换，那么这个切换由谁完成就很重要，可以完全由用户（程序员）来切换，
在用户空间完成切换，也就要在用户空间维护各个线程的栈和寄存器等资源，操作系统对这些线程事不感知的，完全由用户调度（这样也可以充分利用cpu,
如果都是cpu密集型任务的话，但是一个进程的时间片是定的，也就是各个用户线程分摊了改进程的时间片这样并不会让你可以在更短的时间内完成进程的任务，
但是可以实现边下载边播放这样类似的需求，下载总共20秒，播放40秒，下载边播边放最终也要60秒。）。

    但是现在仍然存在一种问题就是，如果一个进程内的多线程是用户线程，操作系统是感知不了的，现在操作系统中只含有进程的PCB，当某个线程进行了IO读写，
然后进行了系统调用，操作系统只能感知这个进程，而操作系统目前的策略（后面的事要依赖前面事情的结果）就是为了充分利用cpu，将这个进程阻塞，切换到另外一个进程，
而被阻塞的进程里所有的线程都将因为分配不到时间片而阻塞等待调度。那么如何避免这种情况呢，其实这种情况其实在实现多进程的时候已经实现了，
就是由操作系统在内核空间来实现多线程，为每个线程维护TCB，这样进程里的每个线程都被操作系统感知，完全由操作系统调度，所有这就叫内核级线程，
这时当进程中一个线程因为进行IO操作时，只阻塞这个线程，而其他的线程可以被操作系统调度分配cpu时间片，这样就可以实现类似WPS在边保存（io)时，
边写字边检查这种功能。线程切换还分同进程内切换，和进程间线程切换，前者切换成本低于进程切换，后者其实也相当于进程切换。

    那现在又有种需求，能不能线程执行IO操作的时候不阻塞不切换到其他线程，可以在该线程内继续完成其他的事。
（其他的事可以交给其他线程来做，用户线程实现不了，内核线程就可以实现了啊，但是等于就创建了两个线程，开销也大，js单线程怎么办？）
那我们想到能不能用用户线程去做，自己在遇到IO时，自己切换到其他执行序列？针对cpu密集计算型可以，但是针对IO不行，因为执行IO读写时，
要陷入到操作系统的内核空间执行，而操作系统策略是进行IO时，为了充分利用CPU切换线程运行，你用户线程在IO时想切换到其他运行序列时是不行，
你必须先进入内核才能发出IO指令，而这个时候用户线程显然时切换不了的，如果你在发出IO指令之前切换用户线程那么你就发出不了IO指令。
所有这个操作系统针对CPU的执行策略所决定的。内核线程也不行，内核线程是操作系统调度的同样遵循这样的策略。

    既然内核线程和用户线程都实现不了某一个线程进行IO操作时，不切换线程，然该线程继续享有未结束的时间片，而用户线程也可以继续享有时间片（但没法切换），
内核线程可以切换完成阻塞后的执行序列（但是只能重新调度，没法继承之前阻塞的线程的剩余的时间片）。那能不能改变操作系统的策略，或者是操作系统提供某种方法。

    那就涉及到IO模型了，比如线程发起了IO操作，可以立马返回，但是如何知道IO操作是否完成呢，一个就是自己阻塞（相当于空轮询，但不会有时间片，
也相当于一种注册（异步），但是不会占用时间片做其他事）在那，直到IO完成，然后自己拷贝到用户空间。
一个就是非阻塞，发起IO操作时，立马返回，但是怎么知道IO操作是否完成呢，那不阻塞在那的话就只能通过不断的轮询是否IO操作完成，这样效率也不高，一直轮询也做不了其他事，
或者说只能做一件事，这样导致完成事件通知的不及时。那能不能线程进行IO操作的时候，立马返回，可以继续在时间片内继续做其他事而不被调度 ，
然后IO完成后由操作系统来通知这个线程，既然操作系统可以通知，那我这个单线程需要有通知接收机制呀，应该也是一串代码呀，可以我一直在执行其他指令序列。
怎么能够即时接收呢，每隔一段时间执行接收的代码，那就相当于轮询了呀，消息接收不够及时。（多线程？让一个线程专门负责接收这种通知，
那不就又类似于一个阻塞，然后另外一个执行，不过这个要好点，因为只有一个在阻塞，而且只做一件事，可以监听所有的通知（epoll)，但终究还是多线程了），那有没有一种方法可以及时收到这种通知呢。

可以，这就是异步的来源，我们可以给操作系统注册一段代码，而这个代码就是用来处理这种通知的，也叫回调函数，这样我们在发起IO操作时（调用操作系统函数），
注册一个回调函数，让操作系统实现在IO完成时，可以直接调用这个回调函数（但是我猜这时同样要切换线程，内核操作IO的线程完成IO后，调用回调函数，其实也相当于切换到用户线程，
但这样线程切换的好处相比线程阻塞后切换其他线程在于，用户线程可以充分利用时间片，阻塞切换其他用户线程时，相当于自己的时间片还有没用完的，而异步时，由操作系统通过中断，
将操作IO的内核线程立马切换到提供回调函数的用户线程，等于用户线程被有限调度了，所有相同时间内异步情况下，用户线程能获得更多的cpu时间片，对于用户体验会更好，这也更符合个人PC的设计理念，
用户至上。而用户线程获得更多的CPU时间片，相对的操作系统的其他内核线程比如监控线程获得的时间片就减少了，但是对于用户体验更重要，所以可以牺牲操作系统级别的线程，换取用户线程更长的cpu时间片。
本来自己做的事情全部让操作系统的内核线程去做去支持。

而windows就是比较典型的面对用户设计的操作系统， Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 IOCP(IO完成端口)，是由操作系统级别实现的异步 I/O，
真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。
可惜的是，在 Linux 下的异步 I/O 是不完善的，aio 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，
并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。主要使用epoll.MAC OS 的 kqueue。

比如js就是单线程的语言，在语言层面上不支持多线程（虽然可以支持了），那么js进行网络IO的时候为什么可以js线程不阻塞可以继续响应用户的操作呢？这就归功于浏览器V8引擎提供的异步支持，
这其实可以类比于操作系统，因为操作系统也支持异步。

IOCP(IO完成端口)是windows下性能最好的IO模型。
windows下的socket也是一种IO，所以完成端口也是最好的socket IO模型。
不幸的是，IO完成端口非常复杂，理解它门槛已经非常很高，而正确使用的门槛比理解它还要高很多。

异步是通信的机制，同样是用户线程，一个线程可以注册回调函数在另外一个线程上，也可以实现异步，epoll(),java的completableFuture。
但是网络有时候说的异步往往指的是，内核线程池直接将IO设备缓冲区拷贝到内核空间，再从内核空间拷贝到用户空间。而epoll()等需要用户线程从内核空间拷贝到用户空间。
所以：
1. 只有IOCP是asynchronous I/O，其他机制或多或少都会有一点阻塞。（多了一层从内核copy数据到应用层的阻塞，从而不能算作asynchronous I/O类）
2. select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善
3. epoll, kqueue、select是Reacor模式，IOCP是Proactor模式。
4. java nio包是select模型。。
